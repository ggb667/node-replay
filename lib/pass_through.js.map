{"version":3,"sources":["pass_through.js"],"names":["HTTP","require","Zlib","ClientRequest","module","exports","passThrough","passThroughFunction","arguments","length","hostname","request","truthy","callback","options","protocol","url","port","path","method","headers","agent","auth","key","cert","http","trailers","addTrailers","on","response","captured","version","httpVersion","statusCode","statusMessage","rawHeaders","Object","assign","body","indexOf","unzip","createUnzip","rawTrailers","pipe","chunk","encoding","push","part","write","end"],"mappings":";;AAAA,MAAMA,OAAOC,QAAQ,MAAR,CAAb;AACA,MAAMC,OAAOD,QAAQ,MAAR,CAAb;;AAEA,MAAME,gBAAgBH,KAAKG,aAA3B;;AAEAC,OAAOC,OAAP,GAAiB,SAASC,WAAT,CAAqBC,mBAArB,EAA0C;AACzD,MAAIC,UAAUC,MAAV,KAAqB,CAAzB,EACEF,sBAAsB,MAAK,IAA3B,CADF,KAEK,IAAI,OAAOD,WAAP,KAAuB,QAA3B,EAAqC;AACxC,UAAMI,WAAWH,mBAAjB;AACAA,0BAAuBI,OAAD,IAAYA,QAAQD,QAAR,KAAqBA,QAAvD;AACD,GAHI,MAGE,IAAI,OAAOH,mBAAP,KAA+B,UAAnC,EAA+C;AACpD,UAAMK,SAAS,CAAC,CAACL,mBAAjB;AACAA,0BAAsB,MAAKK,MAA3B;AACD;;AAED,SAAO,UAASD,OAAT,EAAkBE,QAAlB,EAA4B;AACjC,QAAIN,oBAAoBI,OAApB,CAAJ,EAAkC;AAChC,YAAMG,UAAU;AACdC,kBAAUJ,QAAQK,GAAR,CAAYD,QADR;AAEdL,kBAAUC,QAAQK,GAAR,CAAYN,QAFR;AAGdO,cAAUN,QAAQK,GAAR,CAAYC,IAHR;AAIdC,cAAUP,QAAQK,GAAR,CAAYE,IAJR;AAKdC,gBAAUR,QAAQQ,MALJ;AAMdC,iBAAUT,QAAQS,OANJ;AAOdC,eAAUV,QAAQU,KAPJ;AAQdC,cAAUX,QAAQW,IARJ;AASdC,aAAUZ,QAAQY,GATJ;AAUdC,cAAUb,QAAQa;AAVJ,OAAhB;;AAaA,YAAMC,OAAO,IAAItB,aAAJ,CAAkBW,OAAlB,CAAb;AACA,UAAIH,QAAQe,QAAZ,EACED,KAAKE,WAAL,CAAiBhB,QAAQe,QAAzB;AACFD,WAAKG,EAAL,CAAQ,OAAR,EAAiBf,QAAjB;AACAY,WAAKG,EAAL,CAAQ,UAAR,EAAoB,UAASC,QAAT,EAAmB;AACrC,cAAMC,WAAW;AACfC,mBAAgBF,SAASG,WADV;AAEfC,sBAAgBJ,SAASI,UAFV;AAGfC,yBAAgBL,SAASK,aAHV;AAIfC,sBAAgBN,SAASM,UAJV;AAKff,mBAAgBgB,OAAOC,MAAP,CAAc,EAAd,EAAkBR,SAAST,OAA3B,CALD;AAMfkB,gBAAgB;AAND,SAAjB;AAQA,YAAI,CAAC,MAAD,EAAS,SAAT,EAAoBC,OAApB,CAA4BT,SAASV,OAAT,CAAiB,kBAAjB,CAA5B,MAAsE,CAAC,CAA3E,EAA8E;AAC5E,gBAAMoB,QAAQtC,KAAKuC,WAAL,EAAd;AACAD,gBAAMd,QAAN,GAAiBG,SAASH,QAA1B;AACAc,gBAAME,WAAN,GAAoBb,SAASa,WAA7B;AACAb,qBAAWA,SAASc,IAAT,CAAcH,KAAd,CAAX;AACA,iBAAOV,SAASV,OAAT,CAAiB,kBAAjB,CAAP;AACA,iBAAOU,SAASV,OAAT,CAAiB,gBAAjB,CAAP;AACD;AACDS,iBAASD,EAAT,CAAY,MAAZ,EAAoB,UAASgB,KAAT,EAAgBC,QAAhB,EAA0B;AAC5Cf,mBAASQ,IAAT,CAAcQ,IAAd,CAAmB,CAACF,KAAD,EAAQC,QAAR,CAAnB;AACD,SAFD;AAGAhB,iBAASD,EAAT,CAAY,KAAZ,EAAmB,YAAW;AAC5BE,mBAASJ,QAAT,GAAwBG,SAASH,QAAjC;AACAI,mBAASY,WAAT,GAAwBb,SAASa,WAAjC;AACA7B,mBAAS,IAAT,EAAeiB,QAAf;AACD,SAJD;AAKD,OAzBD;;AA2BA,UAAInB,QAAQ2B,IAAZ,EACE,KAAK,IAAIS,IAAT,IAAiBpC,QAAQ2B,IAAzB,EACEb,KAAKuB,KAAL,CAAWD,KAAK,CAAL,CAAX,EAAoBA,KAAK,CAAL,CAApB;AACJtB,WAAKwB,GAAL;AACD,KAjDD,MAkDEpC;AACH,GApDD;AAqDD,CAhED","file":"pass_through.js","sourcesContent":["const HTTP = require('http');\nconst Zlib = require('zlib');\n\nconst ClientRequest = HTTP.ClientRequest;\n\nmodule.exports = function passThrough(passThroughFunction) {\n  if (arguments.length === 0)\n    passThroughFunction = ()=> true;\n  else if (typeof passThrough === 'string') {\n    const hostname = passThroughFunction;\n    passThroughFunction = (request)=> request.hostname === hostname;\n  } else if (typeof passThroughFunction !== 'function') {\n    const truthy = !!passThroughFunction;\n    passThroughFunction = ()=> truthy;\n  }\n\n  return function(request, callback) {\n    if (passThroughFunction(request)) {\n      const options = {\n        protocol: request.url.protocol,\n        hostname: request.url.hostname,\n        port:     request.url.port,\n        path:     request.url.path,\n        method:   request.method,\n        headers:  request.headers,\n        agent:    request.agent,\n        auth:     request.auth,\n        key:      request.key,\n        cert:     request.cert\n      };\n\n      const http = new ClientRequest(options);\n      if (request.trailers)\n        http.addTrailers(request.trailers);\n      http.on('error', callback);\n      http.on('response', function(response) {\n        const captured = {\n          version:        response.httpVersion,\n          statusCode:     response.statusCode,\n          statusMessage:  response.statusMessage,\n          rawHeaders:     response.rawHeaders,\n          headers:        Object.assign({}, response.headers),\n          body:           []\n        };\n        if (['gzip', 'deflate'].indexOf(captured.headers['content-encoding']) !== -1) {\n          const unzip = Zlib.createUnzip();\n          unzip.trailers = response.trailers;\n          unzip.rawTrailers = response.rawTrailers;\n          response = response.pipe(unzip);\n          delete captured.headers['content-encoding'];\n          delete captured.headers['content-length'];\n        }\n        response.on('data', function(chunk, encoding) {\n          captured.body.push([chunk, encoding]);\n        });\n        response.on('end', function() {\n          captured.trailers     = response.trailers;\n          captured.rawTrailers  = response.rawTrailers;\n          callback(null, captured);\n        });\n      });\n\n      if (request.body)\n        for (let part of request.body)\n          http.write(part[0], part[1]);\n      http.end();\n    } else\n      callback();\n  };\n};\n\n"]}