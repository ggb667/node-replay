{"version":3,"sources":["proxy.js"],"names":["assert","require","EventEmitter","HTTP","HTTPS","Stream","URL","ProxyResponse","Readable","constructor","captured","once","emit","httpVersion","version","httpVersionMajor","split","httpVersionMinor","statusCode","parseInt","statusMessage","STATUS_CODES","headers","Object","assign","rawHeaders","slice","trailers","rawTrailers","connection","_body","body","client","authorized","_read","part","shift","push","setTimeout","msec","callback","setImmediate","notFound","url","status","format","module","exports","ProxyRequest","IncomingMessage","options","proxy","method","toUpperCase","protocol","_defaultAgent","host","hostname","port","realPort","parse","path","auth","agent","globalAgent","cert","key","name","value","toLowerCase","toString","flushHeaders","setHeader","ended","getHeader","removeHeader","addTrailers","timeout","setNoDelay","setSocketKeepAlive","write","chunk","encoding","end","data","error","response","resume","Error","code","errno","flush","abort"],"mappings":"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","file":"proxy.js","sourcesContent":["// A proxy is a function that receives two arguments, a request object and a callback.\n//\n// If it can generate a respone, it calls callback with null and the response object.  Otherwise, either calls callback\n// with no arguments, or with an error to stop the processing chain.\n//\n// The request consists of:\n// url     - URL object\n// method  - Request method (lower case)\n// headers - Headers object (names are lower case)\n// body    - Request body, an array of body part/encoding pairs\n//\n// The response consists of:\n// version   - HTTP version\n// status    - Status code\n// headers   - Headers object (names are lower case)\n// body      - Array of body parts\n// trailers  - Trailers object (names are lower case)\n//\n// This file defines ProxyRequest, which acts as an HTTP ClientRequest that captures the request and passes it to the\n// proxy chain, and ProxyResponse, which acts as an HTTP ClientResponse, playing back a response it received from the\n// proxy.\n//\n// No actual proxies defined here.\n\n\nconst assert            = require('assert');\nconst { EventEmitter }  = require('events');\nconst HTTP              = require('http');\nconst HTTPS             = require('https');\nconst Stream            = require('stream');\nconst URL               = require('url');\n\n// HTTP client response that plays back a captured response.\nclass ProxyResponse extends Stream.Readable {\n\n  constructor(captured) {\n    super();\n    this.once('end', ()=> {\n      this.emit('close');\n    });\n\n    this.httpVersion      = captured.version || '1.1';\n    this.httpVersionMajor = this.httpVersion.split('.')[0];\n    this.httpVersionMinor = this.httpVersion.split('.')[1];\n    this.statusCode       = parseInt(captured.statusCode || 200, 10);\n    this.statusMessage    = captured.statusMessage || HTTP.STATUS_CODES[this.statusCode] || '';\n    this.headers          = Object.assign({ }, captured.headers);\n    this.rawHeaders       = (captured.rawHeaders || [].slice(0));\n    this.trailers         = Object.assign({ }, captured.trailers);\n    this.rawTrailers      = (captured.rawTrailers || []).slice(0);\n    // Not a documented property, but request seems to use this to look for HTTP parsing errors\n    this.connection       = new EventEmitter();\n    this._body            = captured.body.slice(0);\n    this.client           = { authorized: true }\n  }\n\n  _read() {\n    const part = this._body.shift();\n    if (part)\n      this.push(part[0], part[1]);\n    else\n      this.push(null);\n  }\n\n  setTimeout(msec, callback) {\n    if (callback)\n      setImmediate(callback);\n  }\n\n  static notFound(url) {\n    return new ProxyResponse({\n      status: 404,\n      body:   [ `No recorded request/response that matches ${URL.format(url)}` ]\n    });\n  }\n\n}\n\n// HTTP client request that captures the request and sends it down the processing chain.\nmodule.exports = class ProxyRequest extends HTTP.IncomingMessage {\n\n  constructor(options = {}, proxy) {\n    super();\n    this.proxy          = proxy;\n    this.method         = (options.method || 'GET').toUpperCase();\n    const protocol      = options.protocol || (options._defaultAgent && options._defaultAgent.protocol) || 'http:';\n    const [host, port]  = (options.host || options.hostname).split(':');\n    const realPort      = options.port || port || (protocol === 'https:' ? 443 : 80);\n    this.url            = URL.parse(`${protocol}//${host || 'localhost'}:${realPort}${options.path || '/'}`, true);\n    this.auth           = options.auth;\n    this.agent          = options.agent || (protocol === 'https:' ? HTTPS.globalAgent : HTTP.globalAgent);\n    this.cert           = options.cert;\n    this.key            = options.key;\n    this.headers        = {};\n    if (options.headers)\n      for (let name in options.headers) {\n        let value = options.headers[name];\n        if (value != null)\n          this.headers[name.toLowerCase()] = value.toString();\n      }\n  }\n\n  flushHeaders() {\n  }\n\n  setHeader(name, value) {\n    assert(!this.ended, 'Already called end');\n    assert(!this.body, 'Already wrote body parts');\n    this.headers[name.toLowerCase()] = value;\n  }\n\n  getHeader(name) {\n    return this.headers[name.toLowerCase()];\n  }\n\n  removeHeader(name) {\n    assert(!this.ended, 'Already called end');\n    assert(!this.body, 'Already wrote body parts');\n    delete this.headers[name.toLowerCase()];\n  }\n\n  addTrailers(trailers) {\n    this.trailers = trailers;\n  }\n\n  setTimeout(timeout, callback) {\n    if (callback)\n      setImmediate(callback);\n  }\n\n  setNoDelay(/*nodelay = true*/) {\n  }\n\n  setSocketKeepAlive(/*enable = false, initial*/) {\n  }\n\n  write(chunk, encoding, callback) {\n    assert(!this.ended, 'Already called end');\n    this.body = this.body || [];\n    this.body.push([chunk, encoding]);\n    if (callback)\n      setImmediate(callback);\n  }\n\n  end(data, encoding, callback) {\n    assert(!this.ended, 'Already called end');\n\n    if (typeof data === 'function')\n      [ callback, data ] = [ data, null ];\n    else if (typeof encoding === 'function')\n      [ callback, encoding ] = [ encoding, null ];\n\n    if (data) {\n      this.body = this.body || [];\n      this.body.push([ data, encoding ]);\n    }\n    this.ended = true;\n\n    if (callback)\n      setImmediate(callback);\n\n    this.proxy(this, (error, captured)=> {\n      // We're not asynchronous, but clients expect us to callback later on\n      setImmediate(()=> {\n        if (error)\n          this.emit('error', error);\n        else if (captured) {\n          const response = new ProxyResponse(captured);\n          this.emit('response', response);\n          response.resume();\n        } else {\n          const error = new Error(`${this.method} ${URL.format(this.url)} refused: not recording and no network access`);\n          error.code  = 'ECONNREFUSED';\n          error.errno = 'ECONNREFUSED';\n          this.emit('error', error);\n        }\n      });\n    });\n  }\n\n  flush() {\n  }\n\n  abort() {\n  }\n\n};\n\n"]}