{"version":3,"sources":["catalog.js"],"names":["assert","require","debug","File","Path","Matcher","jsStringEscape","NEW_RESPONSE_FORMAT","OLD_RESPONSE_FORMAT","mkpathSync","pathname","existsSync","parent","dirname","mkdirSync","match","name","regexps","regexp","test","parseHeaders","filename","headerLines","only","headers","Object","create","line","slice","value","key","toLowerCase","trim","replace","Array","isArray","push","parseRequest","request","requestHeaders","parseRegexp","rawRegexp","inRegexp","flags","RegExp","split","methodAndPath","method","path","body","url","isResponseFormatNew","statusLine","statusComponents","response","formattedStatus","version","statusCode","parseInt","statusMessage","parseResponse","rawHeaders","reduce","raw","header","trailers","rawTrailers","readAndInitialParseFile","buffer","readFileSync","parts","toString","length","parts0","Buffer","parts1","writeHeaders","file","item","write","module","exports","Catalog","constructor","settings","matchers","_basedir","resolve","getFixturesDir","setFixturesDir","dir","find","host","newMatchers","stat","statSync","isDirectory","files","readdirSync","filter","f","mapping","_read","fromMapping","save","callback","matcher","uid","Date","now","Math","floor","random","tmpfile","error","setImmediate","createWriteStream","encoding","toUpperCase","chunks","part","end","rename","undefined"],"mappings":"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","file":"catalog.js","sourcesContent":["const assert         = require('assert');\nconst debug          = require('./debug');\nconst File           = require('fs');\nconst Path           = require('path');\nconst Matcher        = require('./matcher');\nconst jsStringEscape = require('js-string-escape');\n\nconst NEW_RESPONSE_FORMAT = /HTTP\\/(\\d\\.\\d)\\s+(\\d{3})\\s*(.*)/;\nconst OLD_RESPONSE_FORMAT = /(\\d{3})\\s+HTTP\\/(\\d\\.\\d)/;\n\nfunction mkpathSync(pathname) {\n  if (File.existsSync(pathname))\n    return;\n  const parent = Path.dirname(pathname);\n  if (File.existsSync(parent))\n    File.mkdirSync(pathname);\n  else {\n    mkpathSync(parent);\n    File.mkdirSync(pathname);\n  }\n}\n\n// Returns true if header name matches one of the regular expressions.\nfunction match(name, regexps){\n  for (let regexp of regexps)\n    if (regexp.test(name))\n      return true;\n  return false;\n}\n\n// Parse headers from headerLines.  Optional argument `only` is an array of\n// regular expressions; only headers matching one of these expressions are\n// parsed.  Returns a object with name/value pairs.\nfunction parseHeaders(filename, headerLines, only = null) {\n  const headers = Object.create(null);\n  for (let line of headerLines) {\n    if (line === '')\n      continue;\n    let [name, value] = line.match(/^(.*?)\\:\\s+(.*)$/).slice(1);\n    if (only && !match(name, only))\n      continue;\n\n    const key  = (name || '').toLowerCase();\n    value = (value || '').trim().replace(/^\"(.*)\"$/, '$1');\n    if (Array.isArray(headers[key]))\n      headers[key].push(value);\n    else if (headers[key])\n      headers[key] = [headers[key], value];\n    else\n      headers[key] = value;\n  }\n  return headers;\n}\n\n\nfunction parseRequest(filename, request, requestHeaders) {\n  function parseRegexp(rawRegexp) {\n    const [ inRegexp, flags ] = rawRegexp.match(/^\\/(.+)\\/(i|m|g)?$/).slice(1);\n    return new RegExp(inRegexp, flags || '');\n  }\n\n  assert(request, `${filename} missing request section`);\n  const [ methodAndPath, ...headerLines ] = request.split(/\\n/);\n  let method;\n  let path;\n  let rawRegexp;\n  let regexp;\n  if (/\\sREGEXP\\s/.test(methodAndPath)) {\n    [ method, rawRegexp ]  = methodAndPath.split(' REGEXP ');\n    regexp = parseRegexp(rawRegexp);\n  } else\n    [ method, path ] = methodAndPath.split(/\\s/);\n  assert(method && (path || regexp), `${filename}: first line must be <method> <path>`);\n  assert(/^[a-zA-Z]+$/.test(method), `${filename}: method not valid`);\n\n  const headers = parseHeaders(filename, headerLines, requestHeaders);\n  let body      = headers.body;\n  delete headers.body;\n\n  if (body && /^REGEXP\\s+/.test(body)) {\n    rawRegexp = body.split(/REGEXP\\s+/)[1];\n    body = parseRegexp(rawRegexp);\n  }\n\n  const url = path || regexp;\n  return { url, method, headers, body };\n}\n\nfunction isResponseFormatNew(statusLine) {\n  return /^HTTP/.test(statusLine)\n}\n\nfunction statusComponents(statusLine) {\n  let response = {};\n  if ( isResponseFormatNew(statusLine) ) {\n    const formattedStatus = statusLine.match(NEW_RESPONSE_FORMAT);\n    response.version       = formattedStatus[1];\n    response.statusCode    = parseInt(formattedStatus[2], 10);\n    response.statusMessage = formattedStatus[3].trim();\n  } else {\n    const formattedStatus = statusLine.match(OLD_RESPONSE_FORMAT);\n    response.version       = formattedStatus[2];\n    response.statusCode    = parseInt(formattedStatus[0], 10);\n  }\n  return response;\n}\n\nfunction parseResponse(filename, response, body) {\n  if (response) {\n    const [ statusLine, ...headerLines ] = response.split(/\\n/);\n    const { version, statusCode, statusMessage } = statusComponents(statusLine)\n    const headers         = parseHeaders(filename, headerLines);\n    const rawHeaders      = headerLines.reduce(function(raw, header) {\n      const [name, value] = header.split(/:\\s+/);\n      raw.push(name);\n      raw.push(value);\n      return raw;\n    }, []);\n    return { statusCode, statusMessage, version, headers, rawHeaders, body, trailers: {}, rawTrailers: [] };\n  }\n}\n\nfunction readAndInitialParseFile(filename) {\n  const buffer  = File.readFileSync(filename);\n  const parts   = buffer.toString('utf8').split('\\n\\n');\n  if (parts.length > 2) {\n    const parts0  = new Buffer(parts[0], 'utf8');\n    const parts1  = new Buffer(parts[1], 'utf8');\n    const body    = buffer.slice(parts0.length + parts1.length + 4);\n    return [ parts[0], parts[1], body ];\n  } else\n    return [ parts[0], parts[1], '' ];\n}\n\n\n// Write headers to the File object.  Optional argument `only` is an array of\n// regular expressions; only headers matching one of these expressions are\n// written.\nfunction writeHeaders(file, headers, only = null) {\n  for (let name in headers) {\n    let value = headers[name];\n    if (only && !match(name, only))\n      continue;\n    if (Array.isArray(value))\n      for (let item of value)\n        file.write(`${name}: ${item}\\n`);\n    else\n      file.write(`${name}: ${value}\\n`);\n  }\n}\n\nmodule.exports = class Catalog {\n\n  constructor(settings) {\n    this.settings = settings;\n    // We use this to cache host/host:port mapped to array of matchers.\n    this.matchers = {};\n    this._basedir = Path.resolve('fixtures');\n  }\n\n  getFixturesDir() {\n    return this._basedir;\n  }\n\n  setFixturesDir(dir) {\n    this._basedir = Path.resolve(dir);\n    this.matchers = {};\n  }\n\n  find(host) {\n    // Return result from cache.\n    const matchers = this.matchers[host];\n    if (matchers)\n      return matchers;\n\n    // Start by looking for directory and loading each of the files.\n    // Look for host-port (windows friendly) or host:port (legacy)\n    let pathname = `${this.getFixturesDir()}/${host.replace(':', '-')}`;\n    if (!File.existsSync(pathname))\n      pathname = `${this.getFixturesDir()}/${host}`;\n    if (!File.existsSync(pathname))\n      return null;\n\n    const newMatchers = this.matchers[host] || [];\n    this.matchers[host] = newMatchers;\n\n    const stat = File.statSync(pathname);\n    if (stat.isDirectory()) {\n      let files = File.readdirSync(pathname);\n      // remove dot files from the list\n      files = files.filter(f => !/^\\./.test(f));\n      for (let file of files) {\n        let mapping = this._read(`${pathname}/${file}`);\n        newMatchers.push(Matcher.fromMapping(host, mapping));\n      }\n    } else {\n      const mapping = this._read(pathname);\n      newMatchers.push(Matcher.fromMapping(host, mapping));\n    }\n\n    return newMatchers;\n  }\n\n  save(host, request, response, callback) {\n    const matcher = Matcher.fromMapping(host, { request, response });\n    const matchers = this.matchers[host] || [];\n    matchers.push(matcher);\n    const requestHeaders = this.settings.headers;\n\n    const uid       = `${Date.now()}${Math.floor(Math.random() * 100000)}`;\n    const tmpfile   = `${this.getFixturesDir()}/node-replay.${uid}`;\n    const pathname  = `${this.getFixturesDir()}/${host.replace(':', '-')}`;\n\n    debug(`Creating ${pathname}`);\n    try {\n      mkpathSync(pathname);\n    } catch (error) {\n      setImmediate(function() {\n        callback(error);\n      });\n      return;\n    }\n\n    const filename = `${pathname}/${uid}`;\n    try {\n      const file = File.createWriteStream(tmpfile, { encoding: 'utf-8' });\n      file.write(`${request.method.toUpperCase()} ${request.url.path || '/'}\\n`);\n      writeHeaders(file, request.headers, requestHeaders);\n      if (request.body) {\n        let body = '';\n        for (let chunks of request.body)\n          body += chunks[0];\n        writeHeaders(file, { body: jsStringEscape(body) });\n      }\n      file.write('\\n');\n      // Response part\n      file.write(`HTTP/${response.version || '1.1'} ${response.statusCode || 200} ${response.statusMessage}\\n`);\n      writeHeaders(file, response.headers);\n      file.write('\\n');\n      for (let part of response.body)\n        file.write(part[0], part[1]);\n      file.end(function() {\n        File.rename(tmpfile, filename, callback);\n      });\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n  _read(filename) {\n    const [request, response, part] = readAndInitialParseFile(filename);\n    const body = [[part, undefined]];\n    return {\n      request:  parseRequest(filename, request, this.settings.headers),\n      response: parseResponse(filename, response, body)\n    };\n  }\n\n};\n\n"]}