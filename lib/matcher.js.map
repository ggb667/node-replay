{"version":3,"sources":["matcher.js"],"names":["assert","require","URL","jsStringEscape","module","exports","Matcher","constructor","request","response","url","regexp","hostname","parse","port","path","method","toUpperCase","headers","name","value","toLowerCase","body","version","statusCode","parseInt","statusMessage","slice","trailers","match","test","data","chunks","RegExp","fromMapping","host","mapping","hasPath","length","hasRequest","matchingRequest","resolve","matcher"],"mappings":"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","file":"matcher.js","sourcesContent":["// A matcher is a function that, given a request, returns an appropriate response or nothing.\n//\n// The most common use case is to calling `Matcher.fromMapping(mapping)`.\n//\n// The request consists of:\n// url     - URL object\n// method  - Request method (lower case)\n// headers - Headers object (names are lower case)\n// body    - Request body (for some requests)\n//\n// The response consists of:\n// version   - HTTP version\n// status    - Status code\n// headers   - Headers object (names are lower case)\n// body      - Array of body parts\n// trailers  - Trailers object (names are lower case)\n\n\nconst assert         = require('assert');\nconst URL            = require('url');\nconst jsStringEscape = require('js-string-escape');\n\n// Simple implementation of a matcher.\n//\n// To create a matcher from request/response mapping use `fromMapping`.\nmodule.exports = class Matcher {\n\n  constructor(request, response) {\n    // Map requests to object properties.  We do this for quick matching.\n    assert(request.url || request.regexp, 'I need at least a URL to match request to response');\n    if (request.regexp) {\n      this.hostname = request.hostname;\n      this.regexp   = request.regexp;\n    } else {\n      const url = URL.parse(request.url);\n      this.hostname = url.hostname;\n      this.port     = url.port;\n      this.path     = url.path;\n    }\n\n    this.method   = (request.method && request.method.toUpperCase()) || 'GET';\n    this.headers  = {};\n    if (request.headers)\n      for (let name in request.headers) {\n        let value = request.headers[name];\n        this.headers[name.toLowerCase()] = value;\n      }\n    this.body = request.body;\n\n    // Create a normalized response object that we return.\n    this.response = {\n      version:        response.version || '1.1',\n      statusCode:     response.statusCode && parseInt(response.statusCode, 10) || 200,\n      statusMessage:  response.statusMessage || '',\n      headers:        {},\n      body:           response.body ? response.body.slice(0) : [],\n      trailers:       {}\n    };\n\n    // Copy over header to response, downcase header names.\n    if (response.headers) {\n      const headers = this.response.headers;\n      for (let name in response.headers) {\n        let value = response.headers[name];\n        headers[name.toLowerCase()] = value;\n      }\n    }\n    // Copy over trailers to response, downcase trailers names.\n    if (response.trailers) {\n      const trailers = this.response.trailers;\n      for (let name in response.trailers) {\n        let value = response.trailers[name];\n        trailers[name.toLowerCase()] = value;\n      }\n    }\n  }\n\n\n  // Quick and effective matching.\n  match(request) {\n    const { url, method, headers, body } = request;\n    if (this.hostname && this.hostname !== url.hostname)\n      return false;\n    if (this.regexp) {\n      if (!this.regexp.test(url.path))\n        return false;\n    } else {\n      if (this.port && this.port !== url.port)\n        return false;\n      if (this.path && this.path !== url.path)\n        return false;\n    }\n    if (this.method !== method)\n      return false;\n\n    for (let name in this.headers)\n      if (this.headers[name] !== headers[name])\n        return false;\n\n    if (this.body && body) {\n      let data = '';\n      for (let chunks of body)\n        data += chunks[0];\n      data = jsStringEscape(data);\n\n      return this.body instanceof RegExp ?\n        this.body.test(data) :\n        this.body === data;\n    }\n\n    return true;\n  }\n\n\n  // Returns new matcher function based on the supplied mapping.\n  //\n  // Mapping can contain `request` and `response` object.  As shortcut, mapping can specify `path` and `method` (optional)\n  // directly, and also any of the response properties.\n  static fromMapping(host, mapping) {\n    const hasPath = mapping.path && mapping.path.length;\n    const hasRequest = mapping.request && mapping.request.length;\n    assert(hasPath !== hasRequest);\n    //assert(!!mapping.path ^ !!mapping.request, 'Mapping must specify path or request object');//This is insane\n\n    let matchingRequest;\n    if (mapping.path)\n      matchingRequest = {\n        url:    URL.resolve(`http://${host}/`, mapping.path),\n        method: mapping.method\n      };\n    else if (mapping.request.url instanceof RegExp)\n      matchingRequest = {\n        host:     host,\n        regexp:   mapping.request.url,\n        method:   mapping.request.method,\n        headers:  mapping.request.headers,\n        body:     mapping.request.body\n      };\n    else\n      matchingRequest = {\n        url:      URL.resolve(`http://${host}`, mapping.request.url),\n        method:   mapping.request.method,\n        headers:  mapping.request.headers,\n        body:     mapping.request.body\n      };\n\n    const matcher = new Matcher(matchingRequest, mapping.response || {});\n    return function(request) {\n      if (matcher.match(request))\n        return matcher.response;\n    };\n  }\n\n};\n\n"]}